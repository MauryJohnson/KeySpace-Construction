For Assignment 2, I first required the user to input two arguments which are either both the same name to index, or the name of the file to create the inverted index followed by the name of the directory to read through for files including any cascading directories.

In order to determine if I should interpret the second argument as a file or directory, I try to open the second argument as a directory using DIR* pointer = opendir(argv[2]), and if pointer is NULL, then I know that the second argument is a file, so all I have to do is index the file name in the root directory. If the file does not exist, then I create a text file named argv[1] with no inverted indexes. If the pointer is not NULL, then I know that the second argument is a directory that can be opened within the root, so then I call my recursive directory reading function for that directory to index all files within that directory and its directories if it has any.

I used DIR* pointer, struct dirent* pointer, opendir(char* Path), and readdir(DIR* pointer), which returned a struct dirent*, in order to store the necessary information about whether there was a file or a directory found. 

I used a do while loop which performed a read of the directory given by the path name that is opened. In order to correctly open a directory, I needed to check if the struct dirent* pointer -> d_type is DT_DIR. Next, I had to concatenate "./" to the path name to enter the first directory outside of the root directory, and then "/" for any other directory within the directories outisde of the root directory.

In order to open files correctly, I had to concatenate a "./" to the path name and concatenate the file's name which could be found by using dirent * pointer and checking if pointer->d_type is DT_REG in order to then open the file, store count the occurrences of each word, and store the file name, occurrences or the word(s), and the count of the occurrences into a data structure.

The path name is a string which depends on what stage of the recursion the directory reading function is in. during the root stage, the path is just the directory of argv[2] opened. After the pathname opens this directory, the path name has to be copied and passed into the recursive ReadDir function and then freed. The path name is copied in order to not double free a path name when all directories are finished being read.

To store all of this information, I created a linked list structure which stores the file names and the names of each word in the file. Each token name had to be a letter or a number or a combination of the two, so I used fopen for all file opens along with fscanf in a while loop to read through each file. I used a char* and concatenated every value character into the string. Once a completed string is found, I call a function which returns false if the string occurrence exists within the linked list and immediately stores the new file and occurrence information, or it returns true and just increments the count of the occurrences.

If the file that I am reading has the same name as another file that I am reading, I treat the file as the same named file, so all occurrences will be included with the existing file name in the linked list.

Finally, after storing all of the filenames, tokens contained in each file, and the number of occurrences of each token, I then use argv[1] and use the fopen function to create a file if the file does not exist. If the filename or argv[1] does exist, I prompt the user to enter y to delete and rewrite the file, or any other character to do nothing. I used a function PUT which uses a while loop and iterates through the linked list such that the occurrences, number of occurrences, and file names outputted are in order and in xml format. I used merged sort to sort the ocurrences in the correct order, and I used a visited linked list in order to print out the correct file order from capital letters to lowercase letters to numbers to ".". All pointers used were freed, and there are 0 leaks possible; this was confirmed using valgrind for all my test cases. The running time of the algorithm is O(f(ologo)), where o is the number of strings in each file and f is the number of files opened.
